一、流

	1)流根据方向可以分为输入流(InputStream、Read)和输出流(OutputStream、Write)，这是相对于内存而言的，从内存出来就是输出，到内存中去就是输入
	
	2)流根据读取数据方式又分为字节流和字符流，字节流是按照字节的方式读取，字符流则是按照字符(两个字节)，读取时不会乱码，适合读取纯文本文件	
	
	3)根据流出现的位置，流又可以分为:包装流或者处理流或装饰流和节点流，关闭的时候只需要关闭最外层的包装流(装饰者模式)
	
	4)节点流就是和一个资源绑定在一起，而装饰流在创建时需要给出一个底层对象，该对象也称被装饰者
       
	5)java语言中的流分为四大家族(InputStream，OutputStream，Reader，Writer)
	
	6)字节流都以Stream结尾，字符流都含Reader或Writer
	
	7)字节读取方式会频繁访问磁盘，伤害磁盘并且效率低
	
	8)数组方式读取不会频繁访问磁盘并且效率高，注意不要追用加换行
	
	9)文件输出流创建时加true为追加，不加默认为false覆盖，如果指定文件不存在也会自动创建，但如果文件所在目录不存在就会抛出异常
	
	10)流都实现了AutoCloseable接口，可以把流定义在try()里，这种编写代码的方式叫做try-with-resources， 这是从JDK7开始支持的技术，
		可以在catch语句执行完成后自动关闭流，但需要注意的是，在try()中定义流，如果有涉及到装饰者模式，必须分层定义流(不能一次用长代码定义)
	
	11)BufferedReader的readLine方法一读读一行，但行尾不带换行符，需要手动添加换行符
	
	12)转换流可以将字节流转换成字符流，还可以接收键盘输入(System.in是一个标准的输入流，默认接收键盘的输入)
  
	13)对一个方法进行扩展
	
		1.继承：在子类方法中调用父类方法，缺点是：被增强的对象和被增强内容是固定的，代码耦合度太高，不利于项目的扩展
		
		2.装饰者模式：可以不知道被增强对象的类型，虽然增强内容是固定的，但是增强的对象可以任意

			1]装饰者和被装饰者应该继承含有该方法的同一个类或实现含有该方法的同一个接口
			2]装饰者中含有的被装饰者的底层对象，被装饰者就是被增强的对象
			3]装饰者的构造方法的参数中使用到被装饰者的底层对象
			4]案例:装饰者模式

		3.动态代理(AOP):被增强的对象可以切换，增强的内容也可以切换
			
	14)数据流和数据类型相关，使用该流读取数据，读取顺序必须和该文件的写入顺序相同才能读取到正确的数据存储格式
	15)PrintStream是标准的输出流，默认以字节方式输出到控制台，可以改变输出方向，通常使用这种方式记录日志
	
	16)序列化与反序列化
	
		1.Compile编译(.java-->.class):ObjectOutputStream可以将JAVA对象序列化(Serial)到硬盘上
		2.DeCompile反编译(.class-->.java):ObjectInputStream可以将硬盘中的JAVA对象反序列化(DeSerial)到JVM内存
		3.标识接口起到标识的作用，该接口中没有任何方法
		4.实现了Serializable标识接口的JAVA类，JVM会默认给该类添加static final long serialVersionUID(序列化版本号)
		5.我们应该自己手动写定序列化版本号，防止.class文件改变导致序列化版本号不一致，另外被transient关键字修饰的属性不参加序列化
		6.案例:读取对象
		
二、File类

	1)File类和流无关，是文件或目录路径名的抽象表示形式，代表的是硬盘上的Directory或file，不能通过该类完成文件的读和写		
	2)案例:文件夹复制	