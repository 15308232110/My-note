一、面向对象

	1.面向对象和面向过程的区别(盖饭和蛋炒饭)
	
		面向过程:采用面向过程必须了解整个过程，面向过程每个步骤都有因果关系，每个因果关系都构成了一个步骤，多个步骤又构成一个系统，因为存在因果关系，每个步骤很难分离，当任何一个步骤出现问题，将影响整个系统
				
		面向对象:面向对象会将现实世界分割成不同的对象，实现各个对象后，如果要完成某个功能，就只需要将需要用到的对象协作起来，所以面向对象的扩展能力更强，代码的耦合度低，更符合人的思维方式，更容易分析现实世界
		
		C语言纯面向过程、C++一半面向过程，一半面向对象、Java纯面向对象
		
	2.面向过程的三大特征:封装、继承、多态 
				
	3.类与对象的概念
	
		将现实世界中具有共同特征的事物进行抽象就形成了类，类是引用数据类型，是对象的抽象化，类可以模拟现实世界
		对象就是实际存在的个体，是类的实例化或具体化
		
		从软件开发的生命周期来看，面向对象有三个阶段
		
			OOA-面向对象的分析
			OOD-面向对象的设计
			OOP-面向对象的编程
	
		类 = 属性 + 方法，属性来源于状态，方法来源于动作
	
	4.类的定义 	
	
		类的修饰符 class 类名 extends 父类名称 implements 接口名称{
			类体(由属性和方法组成)
		}
		
	5.对象的创建和使用	
	
		每个类都能创建多个对象
		Student student = new Student();在堆中创建对象，并且把堆中对象的内存地址赋给局部变量student，student引用保存的内存地址指向堆中对象，student只是引用，等号右边的才是对象
		Java中所有new出来的数据统一被存储在堆区中，程序员无法对堆区数据直接操作，只能通过对象的引用间接操作
		
	6.面向对象的封装性

		作用:保证数据的安全性
		属性私有化，并对外提供公开的setter and getter方法
		
	7.构造方法(Constructor)
	
		[修饰符列表] 类名(形式参数列表){
			方法体;
		}
		
		构造方法没有返回值，可以重载
		构造方法可以创建对象并且给成员变量赋予默认值
		调用:new 类名;在堆中开辟空间存储对象，只有在调用构造方法的时候，才会给成员变量赋值
		如果一个类已经手动的提供了构造方法，那么系统不会再提供默认的无参构造方法
			
二、对象和引用
	
							 堆区:存放new出来的对象，没有引用指向的对象由GC回收，GC针对的就是堆区(程序员无法干预垃圾回收)
							/
	.class文件-->装载器-->-栈区:每调一次方法，都会创建一个栈帧，栈帧中存放局部变量
							\
							 方法区:存储.class文件中的代码、静态变量和常量
	
	值传递
	
		基本数据类型:没有涉及到对象，调用其他方法只是复制了一份数据给其他栈帧使用(每个栈帧都有自己的局部变量)
		引用数据类型:涉及到对象，方法共同操作同一个内存地址中的数据，任何一个方法操作对象，会影响到另一个方法
		
三、this关键字

	this是一个引用类型，保存内存地址指向自身，存储在堆中的每一个Java对象都有this		
	this用在成员方法中可以区分成员变量和局部变量，谁去调用方法，this就代表谁，this就是指当前对象，this.可以省略
	this用在构造器中可以调用另一个构造方法，实现代码重用，构造方法中的this只能出现在第一行
	this不能用在静态方法中，因为this代表对象，属于对象级别的
	
四、static关键字

	static{}静态语句块在类加载阶段执行，只执行一次，并且是自上而下的顺序执行
	实例语句块{}在每一次调用构造方法之前都会执行一次，顺序也是自上而下
		
五、设计模式

	1)设计模式是可以重复利用的解决方案
	2)设计模式在1995年由GOF四人组提出
	
	3)设计模式从结构上分为三类：创建型，结构型和行为型

		单例模式是最简单的创建型设计模式，可以保证JVM中某种类型的实例对象永远只有一个
			
			实现单例模式的三个条件
				
				构造方法私有化，使类的外部不能创建该类对象
				声明一个当前类型对象的静态成员
				对外提供一个静态方法获取该对象	
					
			类型
				
				饿汉式单例:在类加载阶段就创建对象
				懒汉式单例:用到对象才会创建
	        
		因为构造器私有化，单例类无法被继承
	      
六、类的继承(代码重用，方法重写)

	1)继承
	
		[修饰符列表] class 子类名 extends 父类名{
			类体;
		}
			
		类和类之间只支持单继承，一个类如果没有显示的继承其他类，默认继承Object(根类)，如果继承其他类，间接继承Object	
		子类可以继承父类的所有数据(除了构造方法)，包括私有数据，但私有数据不能直接访问，只能间接访问
		
	2)方法的覆盖(Override)
	
		1.父类中的方法无法满足子类需求，子类就需要对其重写
		2.重写之后，子类对象调用的是重写后方法
		3.子类重写的方法的方法名、返回值类型、参数列表必须与父类中被重写的方法相同
		4.重写的方法不能比被重写的方法拥有更低的访问权限或抛出更宽泛的异常
		5.私有方法无法被重写，使用多态创建对象后调用方法，执行的的还是父类的方法，虽然可以写一个和父类的私有方法相同的方法，但也只能通过本类创建对象来执行
		6.静态方法不存在重写，因为静态方法执行与对象无关，使用多态创建对象后调用方法，执行的的还是父类的方法，虽然可以写一个和父类的静态方法相同的方法，但也只能通过本类创建对象来执行
		7.构造方法无法被覆盖，因为父类的构造方法无法被继承，但可以调用
		8.覆盖针对的是成员方法，和成员变量无关
		
	3)向上转型(多态)和向下转型(必须要有继承关系，否则编译无法通过)
	
		向上转型(自动类型转换)(upcasting):子-->父
		
			1.父类引用指向子类对象
			2.该父类型引用在编译阶段被程序看作父类型(静态绑定)，运行阶段被看作子类型(动态绑定)
			3.向上转型降低了代码之间的耦合度，增强项目的扩展能力(案例:主人喂宠物)
			4.尽量不要面向具体编程，要面向父类型编程，面向抽象编程(提高代码的可扩展能力)
		
		向下转型(强制类型转换)(downcasting):父-->子
		
			在做强制类型转换的时候程序是存在风险的，为了避免ClassCastException的发生，Java引入了instanceof，(a instanceof Cat)如果结果是true就表示a引用指向堆中的Java对象是Cat类型
			
	3)super关键字
	
		1.super不是引用类型，super存储的不是内存地址，super指向的不是父类对象
		2.super代表的是当前子类对象的父类型特征
		3.子类和父类中都有某个数据(或方法)，如果要在子类中访问父类的数据，需要使用super.
		4.super关键字在方法中的使用范围
		
			1]super不能用在静态方法中，因为super是非静态变量
			2]super可以用在成员方法中
			3]super可以用在构造方法中
			
				1}一个构造方法第一行如果没有this()，也没有显示的去调用super()，系统会默认调用super()，所以父类需要提供无参构造方法
				2}super()的调用只能放在构造方法的第一行，所以super()和this()不能共存，并且super()和this()都是最多只能出现一次
				3]在Java语言中只要是创建Java对象，那么Object中的无参数构造方法一定会执行
				4]通过子类的构造方法去调用父类的构造方法可以给当前子类对象和父类型特征赋值
				5]构造方法执行不一定创建对象，因为调用了父类构造方法，但并不会创建父类对象，就算是可以创建，那万一父类是抽象类呢？
				
	4)final关键字
	
		1.final修饰的类无法被继承
		2.final修饰的方法无法被覆盖
		3.final修饰的局部变量一旦被赋值，不能再改变
		4.final修饰的成员变量必须手动赋值或者在每个构造器中赋值
		5.final和static联用定义常量，常量的名称规范要求字母全部大写
		6.final修饰的引用类型，不能重新指向其他对象，但其属性可以修改
		
	5)abstract关键字
	
		抽象类
		
			抽象类不能创建对象，但抽象类也有构造方法，供子类使用
			非抽象类继承抽象类，必须重写父类的抽象方法	
			抽象类不能被final修饰
			
		抽象方法	
		
			抽象方法应该以分号结束，抽象方法不能有主体
			抽象方法一定出现在抽象类中，但抽象类不一定要有抽象方法
			抽象方法也不能被final修饰
			
	6)接口:[修饰符] interface 接口名{}
	
		1.接口中只能出现常量和抽象方法
		2.接口中的常量都被public static final修饰，可以省略
		3.接口中的抽象方法都被public abstract修饰，可以省略
		4.接口其实是一个特殊的抽象类，特殊在接口是完全抽象的		
		5.接口中没有构造方法，无法被实例化
		6.接口和接口之间可以多继承
		7.一个类可以实现多个接口
		8.一个非抽象的类实现接口，需要将实现的所有接口中的所有的方法重写，只能用public修饰，并且还不能用static修饰
		9.接口使项目分层(变得可插拔)，每一层都面向接口开发，降低了代码间的耦合度，并且可以随意切换接口，效率提高了
		10.抽象类和接口都能完成某个功能时，优先选择接口，因为类可以实现多个接口并且还保留了继承
		11.案例:汽车引擎生产
		
七、Object类

	1)toString方法
	
		1.SUN是这样实现toString方法的
		
			public String toString() {
			
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
			}		
	    
			Object中的toString方法返回类名@对象的内存地址经过哈希算法得出的int类型值再转换成十六进制值，可以将其看做对象在堆中的内存地址
	 		在现实的开发过程中，Object中的toString方法就是用来被重写的，因为业务需求对Object的toString方法实现的结果不满意
			print方法后面括号中如果是一个引用类型，会默认调用引用类型的toString方法
			
	2)equals方法(只能比较引用数据类型)
	
		equals方法只能被引用数据类型调用
		==比较的是内存地址，equals还可以比较值，前提得重写(如何重写?(instanceof))
		在Java中比较两个字符串是否一致，不能用==，只能调用String类重写的equals方法，调用equals方法的对象不能是空，这里注意！字符串常量池
		
	3)finalize方法	
	
		1.finalize方法每个Java对象都有，该方法只会执行一次
		2.finalize方法不需要程序员去调用(不会真正执行)，由系统自动调用
		3.一个对象如果没有更多的引用指向它，则该对象成为垃圾，等待GC的回收，GC在回收这个Java对象之前会先自动调用该对象的finalize方法
		4.程序员只能建议GC回收垃圾(调用System.gc()方法)，虚拟机会尽最大努力回收所有丢弃的对象
		5.多在finalize方法中写入对象被销毁之前需要执行的代码
		6.方法调用finalize方法时对象不一定被回收，可以在方法中让引用重新指向对象													    ****
		
	4)hashCode方法
	
		Object中的hashCode方法：public native int hashCode();
		
		hashCode方法返回的是该对象的哈希码值(Java对象的内存地址经过哈希算法得出的int类型的数值)
		这个方法不是抽象方法，虽然()后面跟的是分号，但被native关键字修饰
		native代表本地调用，其实底层是有代码的，hashCode方法底层就是调用C++代码，Java语言和C++就是靠native联系在一起，
		所以可以认为Java语言不是百分之百开源的，底层有些东西还是看不见，动态链接库文件dll在jre的bin目录下，其底层是C++
		
	5)clone方法(复杂有难度)可以创建并返回此对象的一个副本，再对副本进行操作，可以防止程序在访问对象时对对象进行破坏	
	
八、软件包机制

	1)为了解决类的命名冲突问题，在类名前加命名空间(包机制)
	2)在Java中使用package语句定义包
	3)package语句必须最先出现在.Java源文件中(注释除外)
	4)完整的类名是带有包名的
	5)带有package语句的.java源文件需要这样编译:javac -d 生成路径()(.表示当前路径) Java源文件路径   
	6)带有package语句的.java源文件运行时需要加包名
	7)package定义的全格式:公司域名倒叙.项目名.模块名
	8)import语句用于导入包，方便使用类(导入后使用该类时就不用带包名了)，可以导入多个包
	9)import语句紧跟package语句之下，只有java.lang软件包下所有的类会自动导入
	10)可以在代码里面，直接使用静态导入的方式导入静态方法或者常量：import static 包名.类名.静态属性|静态方法|*
	
九、访问控制权限修饰符:private、缺省、protected、public

	可以限定其他类对该类、该类的属性和该类方法的使用权限
	可以修饰类、修饰方法、修饰变量，类可以被是用public和缺省修饰，内部类还可以被private修饰
	private --> 可以在本类访问
		缺省 --> 可以在一个包下访问
		protected --> 可以在子类中访问
		public --> 可以在任何地方访问
		
十、内部类(OuterClass$InnerClass.class)
	
	内部类可以直接访问外部类的数据(因为内部类中持有外部类的引用Outer.this，包括私有
	内部类也可以继承和实现接口
	
	类的分类
	
		成员内部类
		
			1}成员内部类可以等同看作成员变量
			2}成员内部类中不能有静态声明
			3}成员内部类可以被访问控制权限修饰符修饰
			4}成员内部类可以直接访问外部类的所有数据(因为内部类中持有外部类的引用Outer.this
			5}其他类访问外部类的非私有成员内部类时，必需通过Outer.Inner 变量名 = new Outer().new Inner();的方式来创建内部类对象，才能访问
		
		静态内部类
		
			1}静态内部类可以等同看作静态变量
			2}静态内部类可以被访问控制权限修饰符修饰
			3}静态内部类只能访问外部类的静态数据
			4}外部类访问内部类的静态数据时采用Outer.Inner.的方式来访问
			5}外部类访问内部类的非静态数据时通过Outer.Inner in = new Outer.Inner();的方式创建内部类对象来访问
		
		局部内部类
		
			1}局部内部类等同于局部变量，所以不能被static和访问控制权限修饰符修饰
			2}局部内部类在访问局部变量的时候，局部变量必须使用final修饰(JDK8以后final可以省略了)
			3}局部内部类中不能有静态声明
			4}局部内部类可以直接访问外部类的所有数据
			5}局部内部类只能在被定义的方法中创建对象和调用方法
		
		匿名内部类
		
			1}匿名内部类必须继承一个父类(不指定也会继承Object)或实现一个接口			
			2}匿名内部类用于创建匿名子类或实现类对象，可以理解为带内容的对象
			3}匿名内部类创建对象，new 父类名或者接口名(){定义子类内容}
			4}可以在匿名内部类创建对象时直接用.调用匿名内部类中的所有方法(如果是继承，还包括父类中未被重写的方法)，这种调用方式只能调用一次，
			  但如果将该对象赋给一个引用，就可以多次调用，但只能调用父类或接口中的方法
			4}匿名内部类其实就是一个匿名子类或实现类对象，可以理解为带内容的对象
			5}匿名内部类就是为了简化书写，定义方法
		
十一、UML统一建模语言(图形语言)

	类间关系
	
		1)泛华关系，继承(实线，空心箭头指向父)
		2)实现关系，实现(虚线，空心箭头指向接口)
		3)关联关系，当前类中含有非本类型对象的引用，并将这个引用使用在本类的构造方法的参数列表中，构造本类对象时传入这个引用，从而可以访问到该引用类型的属性(实线，普通箭头指向被引用的类)
		4)聚合关系，整体部分互不依赖，整体无法决定部分的生命周期(空心菱形，指向整体)
		5)合成关系，整体和部分紧密相连，整体的生命周期决定部分的生命周期(实心菱形，指向整体)
		6)依赖关系，类和它的局部变量(虚线箭头，指向局部变量)