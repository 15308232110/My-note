一、多线程的基本概念
	
	1)线程
	
		1.一个进程对应一个运用程序，现代计算机都是支持多进程的，在同一个操作系统中，可以同时启动多个进程
		2.对于单核计算机而言，在同一个时间点上，两个进程不能同时运行，因为计算机的CPU在某个时间点上只能做一件事，
			但是因为计算机在进程之间频繁切换的速度极高，人类感觉每个进程都是不间断的执行
		3.多进程的作用不是提高执行速度，而是提高CPU的使用率，进程间的内存独立
	
	2)线程
		
		1.线程是一个进程中的执行场景，一个进程可以启动多个线程
		2.多线程不是为了提高执行速度，而是提高应用程序的使用率
		3.线程和线程共享堆内存和方法区内存，但栈内存是独立的，一个线程一个栈
		4.多线程可以给现实世界中的人类一种多个线程在同时并发执行的错觉
		
		5.Java程序的运行原理
			
			Java程序启动JVM，等同于启动一个应用程序，也就表示启动了一个进程，该进程会自动启动一个主进程，
			然后主进程去调用某个类的main方法，main方法运行在主线程中
			
二、多线程的定义和使用

	1)继承Thread类或实现Runnable接口，推荐使用后者，因为其保留了类的继承
	2)线程在调用start方法启动线程之后，run方法会自动被调用(该方法中的出现的异常必须处理，不能上抛)，run方法不需要程序员手动调用
	3)所有线程全部结束，程序才停止运行
	
三、线程的生命周期

	线程的生命周期有五个状态:新建、就绪、运行、阻塞、消亡，new表示新建，线程新建之后调用start方法进入就绪状态，
	就绪状态的线程有权利去获取CPU时间片，CPU时间片就是执行权，当线程拿到CPU时间片就会进入运行状态执行run方法，
	如果时间片不够用，则返回到就绪状态，等到下一次得到时间片，就又到运行状态接着执行上次的run方法中的剩余代码，
	run方法结束则线程消亡，其中如果发生阻塞事件，就会从运行状态到阻塞状态，待阻塞解除后，又重新从阻塞状态回到就绪状态
	
四、线程的调度与控制

	1)CPU在某一时刻只能执行一条指令，线程只有得到CPU时间片才可以执行指令，线程只有在单CPU的机器上才不是并行运行的
		
	2)Java虚拟机要负责线程的调度，获得CPU使用权，目前有两种调度模型，一是分时调度，二是抢占式调度，Java使用的是抢占式调度模型
	
	  1.分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片
	 	2.抢占式调度模型:优先级高的线程获取的CPU时间片相对会多一些
	  
	2)线程的优先级(Priority)为1~10，默认是5
	3)sleep方法可以阻塞当前线程，腾出CPU，让给其他线程
	4)yield()静态方法可以给同优先级的线程让位，但是时间不固定
	5)interrupt方法可以依靠异常机制打断线程阻塞，但更推荐使用判断语句来打断线程阻塞
	6)join方法用来合并线程，当前线程调用这个方法合并后，当前线程在另一个线程结束后才能继续执行
		
五、线程的同步

	1)异步编程模型:线程之间互不干预
	2)同步编程模型:同一时间只能执行一个线程
	
	3)线程同步机制
	
		1.减少应用程序的使用率以保障数据安全(等同单线程)
		2.在多线程环境下，共享同一个涉及到修改的数据就需要使用线程同步机制
		3.synchronized关键字可以出现多次，用来锁语句块(更灵活)或成员方法(对象锁，一个对象只有一个)也可以用来锁静态方法(类锁，一个类只有一个)
		4.线程遇到synchronized锁，会拿锁执行代码，其他线程在该线程执行被锁代码时也遇到了这个synchronized锁，
			就会等待拿锁线程归还锁并拿锁后，才能执行被锁的代码
		5.案例:账户取款
		6.案例:死锁
		7.案例:交替输出
	
六、守护线程	

	1)线程又可以分为守护线程和用户线程
	2)守护线程一般都是无限执行的，只要有一个用户线程存在，守护线程就不会结束，例如GC就是一个守护线程
	3)setDaemon方法可以将用户线程转换成守护线程